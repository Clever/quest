// Generated by CoffeeScript 1.9.3
var Promise, _, cookiejar, handle, handle_options, http, https, is_uri, normalize_uri, qs, quest, should_redirect, url,
  slice = [].slice;

qs = require('qs');

http = require('http');

https = require('https');

_ = require('underscore');

_.mixin(require('underscore.deep'));

url = require('url');

cookiejar = require('cookiejar');

Promise = require('es6-promise').Promise;

handle = {
  form: function(options) {
    if (options.form == null) {
      return;
    }
    if (!('content-type' in options.headers)) {
      options.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8';
    }
    return options.body = qs.stringify(options.form).toString('utf8');
  },
  qs: function(options) {
    if (options.qs == null) {
      return;
    }
    return options.path = options.path + "?" + (qs.stringify(options.qs));
  },
  json: function(options) {
    if (options.json == null) {
      return;
    }
    if (!('accept' in options.headers)) {
      options.headers.accept = 'application/json';
    }
    if (options.json === true) {
      return;
    }
    if (!('content-type' in options.headers)) {
      options.headers['content-type'] = 'application/json';
    }
    return options.body = JSON.stringify(options.json);
  },
  jar: function(options) {
    var access_info, cookie_string;
    access_info = {
      domain: options.host,
      path: options.pathname
    };
    cookie_string = _(options.jar.getCookies(access_info)).invoke('toValueString').join('; ');
    options.headers.cookie = options.headers.cookie == null ? '' : options.headers.cookie + "; ";
    return options.headers.cookie = "" + options.headers.cookie + cookie_string;
  }
};

handle_options = function(options) {
  return _(handle).chain().values().each(function(handler) {
    return handler(options);
  });
};

is_uri = function(uri) {
  return /^https?:\/\//i.test(uri);
};

normalize_uri = function(options) {
  if (!is_uri(options.uri)) {
    return options.uri = "http://" + options.uri;
  }
};

should_redirect = function(options, resp) {
  var ref, ref1;
  return (299 < (ref = resp.statusCode) && ref < 400) && (options.followAllRedirects || (options.followRedirects && ((ref1 = options.method) !== 'PATCH' && ref1 !== 'PUT' && ref1 !== 'POST' && ref1 !== 'DELETE')));
};

quest = function(options, cb) {
  var https_pattern, key, parsed_uri, ref, req, request_module, val;
  if (!cb) {
    return new Promise(function(resolve, reject) {
      return quest(options, function(err, response, body) {
        if (err != null) {
          return reject(err);
        }
        response.body = body;
        return resolve(response);
      });
    });
  }
  if (_(options).isString()) {
    options = {
      uri: options
    };
  }
  options = _.deepClone(options);
  if (options.uri == null) {
    options.uri = options.url;
  }
  cb = _(cb).once();
  if ((options != null ? options.uri : void 0) == null) {
    return cb(new Error('Options does not include uri'));
  }
  if (!_(options.uri).isString()) {
    return cb(new Error("Uri " + (JSON.stringify(options.uri)) + " is not a string"));
  }
  normalize_uri(options);
  https_pattern = /^https:/i;
  request_module = https_pattern.test(options.uri) ? https : http;
  ref = options.headers;
  for (key in ref) {
    val = ref[key];
    if (!(key !== key.toLowerCase())) {
      continue;
    }
    options.headers[key.toLowerCase()] = val;
    delete options.headers[key];
  }
  parsed_uri = null;
  try {
    parsed_uri = url.parse(options.uri);
  } catch (_error) {}
  if (parsed_uri == null) {
    return cb(new Error("Failed to parse uri " + options.uri));
  }
  _(options).defaults(parsed_uri, {
    port: request_module === http ? 80 : 443,
    headers: {},
    method: 'get',
    followRedirects: true,
    followAllRedirects: false,
    maxRedirects: 10,
    jar: new cookiejar.CookieJar()
  });
  _(options.headers).defaults({
    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_3) AppleWebKit/537.16 (KHTML, like Gecko) Chrome/24.0.1297.0 Safari/537.16'
  });
  handle_options(options);
  if (options.body != null) {
    options.body = new Buffer(options.body);
    options.headers['content-length'] = options.body.length;
  }
  options.method = options.method.toUpperCase();
  req = request_module.request(options, function(resp) {
    var add_data, body, cookies, extend_maybe, parts, redirect_options, ref1;
    resp.request = _({}).chain().extend(req).extend(options).value();
    cookies = resp != null ? (ref1 = resp.headers) != null ? ref1['set-cookie'] : void 0 : void 0;
    if (options.jar !== false && (cookies != null)) {
      options.jar.setCookies(_(cookies).isArray() ? cookies : [cookies]);
    }
    if (should_redirect(options, resp)) {
      if (options.maxRedirects === 0) {
        return req.emit('error', new Error('Exceeded max redirects'));
      }
      redirect_options = {
        json: options.json != null ? true : void 0,
        method: options.followAllRedirects ? 'GET' : options.method,
        uri: resp.headers.location,
        maxRedirects: options.maxRedirects - 1
      };
      extend_maybe = function() {
        var i, len, param, params, results;
        params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        results = [];
        for (i = 0, len = params.length; i < len; i++) {
          param = params[i];
          if (options[param] != null) {
            results.push(redirect_options[param] = options[param]);
          }
        }
        return results;
      };
      extend_maybe('jar', 'ended', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'agent', 'rejectUnauthorized', 'secureProtocol');
      if (!is_uri(redirect_options.uri)) {
        redirect_options.uri = url.resolve(options.href, redirect_options.uri);
      }
      resp.resume();
      return quest(redirect_options, cb);
    }
    body = void 0;
    parts = [];
    add_data = function(part) {
      if (part == null) {
        return;
      }
      return parts.push(part);
    };
    resp.on('data', add_data);
    return resp.on('end', function(part) {
      add_data(part);
      body = Buffer.concat(parts);
      if (!options.raw) {
        body = body.toString("utf8");
      }
      try {
        if (options.json) {
          body = JSON.parse(body);
        }
      } catch (_error) {}
      return cb(null, resp, body);
    });
  });
  if (options.timeout) {
    setTimeout(function() {
      var e;
      req.abort();
      e = new Error("ETIMEDOUT");
      e.code = "ETIMEDOUT";
      return req.emit("error", e);
    }, options.timeout);
  }
  req.on('error', cb);
  if (options.body != null) {
    req.write(options.body);
  }
  return req.end();
};

quest.jar = function() {
  var jar;
  jar = cookiejar.CookieJar();
  jar.add = jar.setCookie;
  jar.get = function(uri) {
    var parts;
    parts = url.parse(uri);
    return jar.getCookies({
      domain: parts.host,
      path: parts.pathname
    });
  };
  return jar;
};

quest.cookie = cookiejar.Cookie;

module.exports = quest;
